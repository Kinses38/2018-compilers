/*******************************
 ***** SECTION 1 - OPTIONS *****
 *******************************/

options { JAVA_UNICODE_ESCAPE = true; 
		  IGNORE_CASE = true;
		  DEBUG_TOKEN_MANAGER= false;}
/*********************************
 ***** SECTION 2 - USER CODE *****
 *********************************/

PARSER_BEGIN(CalParser)
public class CalParser {
	public static void main(String args[]){
		CalParser parser;
		if (args.length == 0){
			System.out.println("CAL parser: Reading from input: ");
			parser = new CalParser(System.in);
		} else if (args.length == 1) {
			System.out.println("CAL Parser: Reading from file " + args[0] + "..");
		
		try {
			parser = new CalParser(new java.io.FileInputStream(args[0]));
		} catch (java.io.FileNotFoundException e) {
			System.out.println("CAL Parser: File " + args[0] + "not found.");
			return;
			}
		}
		else {
			System.out.println("CAL Parser: Usage is one of:");
			System.out.println("		java CalParser < inputfile");
			System.out.println("OR");
			System.out.println("		java CalParser inputfile");
			return;
		}
		
		try {
			parser.Prog();
			System.out.println("CAL Parser: CAL program parsed successfully");
			}catch (ParseException e) {
				System.out.println(e.getMessage());
				System.out.println("CAL Parser: Encountered errors during parse.");

		}
	}
}
PARSER_END(CalParser)

/*****************************************
 ***** SECTION 3 - TOKEN DEFINITIONS *****
 *****************************************/

TOKEN_MGR_DECLS:
{
	static int commentNesting = 0;
}

SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
	  " "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
}

SKIP : /* Comments */
{
	"/*" { commentNesting ++;} : IN_COMMENT
	| <"//" ([" "-"~"])* ("\n" | "\r" | "\r\n") >
}

<IN_COMMENT> SKIP :
{
	  "/*" { commentNesting++; }
	| "*/" { commentNesting --;
			 if (commentNesting == 0)
					SwitchTo(DEFAULT);
			}
	| <~[]>
}

TOKEN : /*Keywords and Punctuation */
{
	<COMMA : ",">
	|<SEMIC : ";">
	|<COLON : ":">
	|<ASSIGN : ":=">
	|<LB : "(">
	|<RB : ")">
	|<PLUS : "+">
	|<MINUS : "-">
	|<NOT : "~">
	|<OR : "|">
	|<AND : "&">
	|<EQUAL : "=">
	|<NEQ : "!=">
	|<LT : "<">
	|<LTE : "<=">
	|<GT : ">">
	|<GTE : ">=">

	|<VAR : "variable">
	|<CONS : "constant">
	|<RET : "return">
	|<INT : "integer">
	|<BOOL : "boolean">
	|<VOID : "void">
	|<MAIN : "main">
	|<IF : "if">
	|<ELSE : "else">
	|<TRUE : "true">
	|<FALSE : "false">
	|<WHILE : "while">
	|<BEGIN : "begin">
	|<END : "end">
	|<IS : "is">
	|<SSKIP : "skip">

	|< #LETTER: (["a"-"z", "A"-"Z"])>
	|< IDENTIFIER: <LETTER> (<LETTER> | <NUMBER> | "_")* >
	|< #DIGIT: ["0" - "9"]>
	|< NUMBER: ("-" ["1" - "9"] (<DIGIT>)*)
			   |( ["1" - "9"] (<DIGIT>)* ) 
			   | "0">	
	|< Other : ~[]>
}


/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

void Prog() : {}
{
	decl_list() 
	function_list() 
	main()
	<EOF> 
}

void decl_list() : {}
{
	(decl() <SEMIC> decl_list()| {} )
}

void decl() : {}
{
	var_decl() | const_decl()
}

void var_decl() : {}
{
	<VAR> <IDENTIFIER> <COLON> type()
}

void const_decl() : {}
{
	<CONS> <IDENTIFIER> <COLON> <ASSIGN> expression()
}

void function_list() : {}
{
	(function() function_list() | {})
}

void function() : {}
{
	type() <IDENTIFIER> <LB>(parameter_list())<RB> <IS>
	(decl_list())
	<BEGIN>
	(statement_block())
	<RET> <LB>expression() | {} <RB>  //Is this an error or java issue?
	<END>
}

void type() : {}
{
	<INT> | <BOOL> | <VOID>
}

//replace nemp_param_list 
void parameter_list() : {}
{
	 <IDENTIFIER><COLON>type() (<COMMA> <IDENTIFIER><COLON>type())* | {}
}

/*Conflict between one or more param
void nemp_parameter_list() : {}
{
    It is a parameter followed by 1 or 0 empty lists.
	<IDENTIFIER><COLON>type() (<COMMA> nemp_parameter_list())*
}
*/

void main() : {}
{
	<MAIN>
	<BEGIN>
	decl_list()
	statement_block()	
}

void statement_block() : {}
{
	statement() statement_block() | {}
}

//Conflict between ID > Exp | ID > Arg_list
void statement() : {}
{
	  <IDENTIFIER> statement_beta()
	| <BEGIN> (statement_block()) <END>
	| <IF> condition() <BEGIN> statement_block() <END>
	| <ELSE> <BEGIN> statement_block() <END>
	| <WHILE> condition() <BEGIN> statement_block() <END>
	| <SSKIP> <SEMIC>
}

void statement_beta() : {}
{
	  <ASSIGN> expression() <SEMIC>
	| <LB> arg_list() <RB> <SEMIC>
}

//Left hand recursion: Expression > Fragment > Expression.
void expression() : {}
{
	expression_beta() (binary_arith_op() expression_beta())*  
}

//Separate out original Expression
void expression_beta() : {}
{
	(LOOKAHEAD(2)
	//replace fragment completely.
	 (<MINUS>)? <IDENTIFIER>
	| <NUMBER>
	| <TRUE>
	| <FALSE>
	// remainder of original expression()
	| <LB> expression() <RB>
	| <IDENTIFIER> <LB> arg_list() <RB>)
}

void binary_arith_op() : {}
{
	<PLUS> | <MINUS>
}

/*Replaced by expression
* void fragment() : {}
* {
* 	<IDENTIFIER>
*	| <MINUS> <IDENTIFIER>
*	| <NUMBER>
*	| <TRUE>
*	| <FALSE>
*	| expression()
* }
*/

//Left hand recursion: Condition > Condition 
void condition() : {}
{
	  condition_beta() ((<AND> | <OR>) condition_beta())*
}

void condition_beta() : {}
{
	//replace the easy condition rules.
	  <NOT> condition()
	| <LB> condition() <RB>
	| expression() comp_op() expression()
}

void comp_op() : {}
{
	  <EQUAL> 
	| <NEQ>
	| <LT>
	| <LTE>
	| <GT>
	| <GTE> 
}

//redefine using Kleene to avoid choice conflict
void arg_list() : {}
{
	<IDENTIFIER> (<COMMA> <IDENTIFIER>)* | {}
}

/*
void nemp_arg_list() : {}
{
	<IDENTIFIER> | <IDENTIFIER> <COMMA> nemp_arg_list()
}
*/
